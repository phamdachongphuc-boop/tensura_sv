
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { SaveData, UserProfile, Mail, BattleState, GAME_SERVERS, Character } from '../types';

export interface WorldChatMessage {
  id: number;
  server_id: string;
  username: string;
  content: string;
  is_admin: boolean;
  timestamp: number;
}

const SUPABASE_URL = "https://nrcubosxzyyjzjhfcvwq.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5yY3Vib3N4enl5anpqaGZjdndxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAyMTA3OTAsImV4cCI6MjA4NTc4Njc5MH0.sz43w_xWD2bHKyaWJLATpNZK5SIc_jvTYUghSX_hw8w"; 

const DB_SETUP_SQL = `
-- 1. Bảng lưu trữ người chơi
create table if not exists tensura_players (
  username text primary key,
  password text not null,
  server_id text not null,
  is_admin boolean default false,
  is_banned boolean default false,
  last_active bigint,
  save_data jsonb,
  mailbox jsonb default '[]',
  created_at timestamptz default now()
);

-- 2. Bảng chat thế giới
create table if not exists tensura_world_chat (
  id bigint generated by default as identity primary key,
  server_id text not null,
  username text not null,
  content text not null,
  is_admin boolean default false,
  timestamp bigint not null,
  created_at timestamptz default now()
);

-- 3. Bảng đấu trường PvP
create table if not exists tensura_battles (
  id bigint generated by default as identity primary key,
  server_id text not null,
  challenger text not null,
  target text not null,
  status text not null,
  winner text,
  turn text,
  logs jsonb default '[]',
  p1_hp bigint, p1_max_hp bigint,
  p2_hp bigint, p2_max_hp bigint,
  created_at timestamptz default now()
);

-- 4. Kích hoạt Realtime
alter publication supabase_realtime add table tensura_world_chat;
alter publication supabase_realtime add table tensura_battles;
`;

class AuthService {
    private supabase: SupabaseClient;
    private serverId = 'sv1';
    private chatSubscription: any = null;
    private battleSubscription: any = null;
    public ADMIN_ID = 'pojani0b';

    constructor() {
        const savedServer = localStorage.getItem('tensura_selected_server');
        if (savedServer) this.serverId = savedServer;
        this.supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
    }

    setServer(id: string) {
        this.serverId = id;
        localStorage.setItem('tensura_selected_server', id);
    }

    getServerId() { return this.serverId; }
    
    getServerName() {
        return GAME_SERVERS.find(s => s.id === this.serverId)?.name || 'Unknown Server';
    }

    async checkConnection() {
        try {
            const { error } = await this.supabase.from('tensura_players').select('count', { count: 'exact', head: true });
            if (error) throw error;
            return { online: true, message: 'Kết nối Tiếng Nói Thế Giới ổn định.' };
        } catch (e: any) {
            return { online: false, message: 'Lỗi kết nối: ' + e.message };
        }
    }

    async register(username: string, password: string) {
        if (username === this.ADMIN_ID && password !== 'admin2025') {
            return { success: false, error: 'Mật khẩu Admin không chính xác.' };
        }

        const { data: existing } = await this.supabase
            .from('tensura_players')
            .select('username')
            .eq('username', username)
            .single();

        if (existing) return { success: false, error: 'Định danh linh hồn đã tồn tại.' };

        const newUser = {
            username,
            password,
            server_id: this.serverId,
            is_admin: username === this.ADMIN_ID,
            last_active: Date.now(),
            save_data: null,
            mailbox: []
        };

        const { error } = await this.supabase.from('tensura_players').insert(newUser);
        if (error) return { success: false, error: error.message };
        return { success: true };
    }

    async login(username: string, password: string) {
        const { data, error } = await this.supabase
            .from('tensura_players')
            .select('*')
            .eq('username', username)
            .eq('password', password)
            .single();

        if (error || !data) return { user: null, error: 'Sai tên đăng nhập hoặc mật khẩu.' };
        if (data.is_banned) return { user: null, error: 'Linh hồn này đã bị phong ấn (Banned).' };

        const userProfile: UserProfile = {
            username: data.username,
            createdAt: new Date(data.created_at).getTime(),
            isAdmin: data.is_admin,
            isBanned: data.is_banned,
            lastActive: data.last_active
        };

        localStorage.setItem('tensura_session', JSON.stringify(userProfile));
        return { user: userProfile };
    }

    logout() {
        localStorage.removeItem('tensura_session');
        if (this.chatSubscription) this.chatSubscription.unsubscribe();
        if (this.battleSubscription) this.battleSubscription.unsubscribe();
    }

    getCurrentUserLocal(): UserProfile | null {
        try {
            return JSON.parse(localStorage.getItem('tensura_session') || 'null');
        } catch (e) { return null; }
    }

    async getCurrentUser() { return this.getCurrentUserLocal(); }

    async getAllUsers() {
        const { data } = await this.supabase
            .from('tensura_players')
            .select('*')
            .eq('server_id', this.serverId)
            .order('last_active', { ascending: false });
        return data?.map(u => ({
            username: u.username,
            createdAt: new Date(u.created_at).getTime(),
            isAdmin: u.is_admin,
            isBanned: u.is_banned,
            lastActive: u.last_active,
            saveData: u.save_data
        })) || [];
    }

    async saveGameData(username: string, data: SaveData) {
        const { error } = await this.supabase.from('tensura_players').update({ save_data: data, last_active: Date.now() }).eq('username', username);
        if (error) return { success: false, error: error.message };
        return { success: true };
    }

    async loadGameData(username: string): Promise<SaveData | null> {
        const { data } = await this.supabase.from('tensura_players').select('save_data').eq('username', username).single();
        return data?.save_data || null;
    }

    async deleteAccount(username: string) {
        await this.supabase.from('tensura_players').delete().eq('username', username);
    }

    async deleteGameData(username: string) {
        await this.supabase.from('tensura_players').update({ save_data: null }).eq('username', username);
    }

    async banUser(username: string) {
        await this.supabase.from('tensura_players').update({ is_banned: true }).eq('username', username);
    }

    async unbanUser(username: string) {
        await this.supabase.from('tensura_players').update({ is_banned: false }).eq('username', username);
    }

    async adminDeleteUser(username: string) {
        await this.deleteAccount(username);
    }

    getDatabaseSetupSQL() {
        return DB_SETUP_SQL;
    }

    async getMailbox(username: string): Promise<Mail[]> {
        const { data } = await this.supabase.from('tensura_players').select('mailbox').eq('username', username).single();
        return data?.mailbox || [];
    }

    async sendMail(to: string, mail: Partial<Mail>) {
        const box = await this.getMailbox(to);
        const newMail: Mail = {
            id: Date.now().toString(),
            sender: mail.sender || 'Hệ thống',
            title: mail.title || 'Thông báo',
            content: mail.content || '',
            type: mail.type || 'TEXT',
            attachment: mail.attachment,
            timestamp: Date.now(),
            isRead: false,
            isClaimed: false
        };
        box.unshift(newMail);
        await this.supabase.from('tensura_players').update({ mailbox: box }).eq('username', to);
    }

    async markMailRead(username: string, mailId: string) {
        const box = await this.getMailbox(username);
        const updatedBox = box.map(m => m.id === mailId ? { ...m, isRead: true } : m);
        await this.supabase.from('tensura_players').update({ mailbox: updatedBox }).eq('username', username);
    }

    async claimMailReward(username: string, mailId: string) {
        const box = await this.getMailbox(username);
        let claimed = false;
        const updatedBox = box.map(m => {
            if (m.id === mailId && !m.isClaimed) {
                claimed = true;
                return { ...m, isClaimed: true };
            }
            return m;
        });
        if (claimed) {
            await this.supabase.from('tensura_players').update({ mailbox: updatedBox }).eq('username', username);
            return true;
        }
        return false;
    }

    async getWorldChatHistory(limit: number): Promise<WorldChatMessage[]> {
        const { data } = await this.supabase.from('tensura_world_chat').select('*').eq('server_id', this.serverId).order('timestamp', { ascending: true }).limit(limit);
        return data || [];
    }

    async sendWorldChatMessage(username: string, content: string, isAdmin: boolean) {
        const newMsg = { server_id: this.serverId, username, content, is_admin: isAdmin, timestamp: Date.now() };
        const { error } = await this.supabase.from('tensura_world_chat').insert(newMsg);
        return !error;
    }

    subscribeToWorldChat(onMsg: (p: any) => void, onStatus: (s: string) => void) {
        const channel = this.supabase.channel(`world_chat_${this.serverId}`)
            .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'tensura_world_chat', filter: `server_id=eq.${this.serverId}` }, (payload) => onMsg(payload))
            .subscribe((status) => onStatus(status));
        return () => this.supabase.removeChannel(channel);
    }

    async createBattle(challenger: string, target: string, p1hp: number, p1max: number, p2hp: number, p2max: number): Promise<boolean | string> {
        try {
            await this.supabase.from('tensura_battles').delete().or(`challenger.eq.${challenger},target.eq.${challenger}`);
            const newBattle = {
                server_id: this.serverId,
                challenger,
                target,
                status: 'PENDING',
                turn: challenger,
                logs: [],
                p1_hp: p1hp, p1_max_hp: p1max,
                p2_hp: p2hp, p2_max_hp: p2max
            };
            const { error } = await this.supabase.from('tensura_battles').insert(newBattle);
            if (error) {
                if (error.code === '42P01') return 'MISSING_TABLE';
                return false;
            }
            return true;
        } catch (e) {
            return false;
        }
    }

    subscribeToBattles(username: string, cb: (payload: any) => void) {
        const channel = this.supabase.channel(`battles_${this.serverId}`)
            .on('postgres_changes', { event: '*', schema: 'public', table: 'tensura_battles', filter: `server_id=eq.${this.serverId}` }, (payload) => cb(payload))
            .subscribe();
        return () => this.supabase.removeChannel(channel);
    }

    async performBattleAction(battle: BattleState, user: UserProfile, skillName: string, attackerStats: Character) {
        const isChallenger = user.username === battle.challenger;
        const opponentName = isChallenger ? battle.target : battle.challenger;
        const damage = Math.max(250000, (attackerStats.attributes.strength + attackerStats.attributes.magic) * 5);

        let n1hp = BigInt(battle.p1_hp);
        let n2hp = BigInt(battle.p2_hp);
        
        if (isChallenger) n2hp = n2hp - BigInt(damage);
        else n1hp = n1hp - BigInt(damage);

        const newLog = { turn: (battle.logs.length || 0) + 1, actor: user.username, skill: skillName, damage, description: `Gây ${damage.toLocaleString()} sát thương!` };
        const updatedLogs = [...(battle.logs || []), newLog];

        if (n1hp <= 0n || n2hp <= 0n) {
            await this.supabase.from('tensura_battles').update({ logs: updatedLogs, p1_hp: Number(n1hp), p2_hp: Number(n2hp), status: 'FINISHED', winner: n1hp > 0n ? battle.challenger : battle.target }).eq('id', battle.id);
        } else {
            await this.supabase.from('tensura_battles').update({ p1_hp: Number(n1hp), p2_hp: Number(n2hp), logs: updatedLogs, turn: opponentName }).eq('id', battle.id);
        }
    }

    async surrenderBattle(battleId: number, username: string) {
        const { data: battle } = await this.supabase.from('tensura_battles').select('*').eq('id', battleId).single();
        if (!battle) return;
        const winner = battle.challenger === username ? battle.target : battle.challenger;
        await this.supabase.from('tensura_battles').update({ 
            status: 'FINISHED', 
            winner 
        }).eq('id', battleId);
    }

    async checkPendingInvite(username: string): Promise<BattleState | null> {
        const { data } = await this.supabase.from('tensura_battles').select('*').eq('status', 'PENDING').eq('target', username).single();
        return data as BattleState;
    }

    async checkActiveBattle(username: string): Promise<BattleState | null> {
        const { data } = await this.supabase.from('tensura_battles').select('*').eq('status', 'IN_PROGRESS').or(`challenger.eq.${username},target.eq.${username}`).single();
        return data as BattleState;
    }

    async acceptBattle(id: number) { await this.supabase.from('tensura_battles').update({ status: 'IN_PROGRESS' }).eq('id', id); }
    async declineBattle(id: number) { await this.supabase.from('tensura_battles').update({ status: 'DECLINED' }).eq('id', id); }
    async getBattle(id: number) { const { data } = await this.supabase.from('tensura_battles').select('*').eq('id', id).single(); return data as BattleState; }

    subscribeToChanges(cb: Function) {
        const channel = this.supabase.channel('players_changes')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'tensura_players' }, () => cb())
            .subscribe();
        return () => this.supabase.removeChannel(channel);
    }
}

export const authService = new AuthService();
